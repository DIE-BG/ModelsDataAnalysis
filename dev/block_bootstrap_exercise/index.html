<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulation Study · ModelsDataAnalysis</title><meta name="title" content="Simulation Study · ModelsDataAnalysis"/><meta property="og:title" content="Simulation Study · ModelsDataAnalysis"/><meta property="twitter:title" content="Simulation Study · ModelsDataAnalysis"/><meta name="description" content="Documentation for ModelsDataAnalysis."/><meta property="og:description" content="Documentation for ModelsDataAnalysis."/><meta property="twitter:description" content="Documentation for ModelsDataAnalysis."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ModelsDataAnalysis</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../periodogram/">Frequency Analysis</a></li><li><span class="tocitem">Block Bootstrap</span><ul><li class="is-active"><a class="tocitem" href>Simulation Study</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Bootstraping-methods-for-dependent-data"><span>Bootstraping methods for dependent data</span></a></li><li><a class="tocitem" href="#Basic-simulation-exercise"><span>Basic simulation exercise</span></a></li><li><a class="tocitem" href="#Results-for-the-sample-mean"><span>Results for the sample mean</span></a></li><li><a class="tocitem" href="#Results-for-the-sample-variance"><span>Results for the sample variance</span></a></li><li><a class="tocitem" href="#Results-of-the-sample-autocorrelation-function"><span>Results of the sample autocorrelation function</span></a></li><li><a class="tocitem" href="#Results-of-the-sample-correlation-matrix"><span>Results of the sample correlation matrix</span></a></li><li><a class="tocitem" href="#Unified-metric-for-comparing-block-bootstrap-metrics"><span>Unified metric for comparing block bootstrap metrics</span></a></li><li><a class="tocitem" href="#Optimal-block-size-from-the-literature"><span>Optimal block size from the literature</span></a></li><li><a class="tocitem" href="#Concluding-remarks"><span>Concluding remarks</span></a></li><li><a class="tocitem" href="#Appendix:-Normalized-MSE-interpretation"><span>Appendix: Normalized MSE interpretation</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Detailed Results</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../mean/">Mean Analysis</a></li><li><a class="tocitem" href="../std/">Variance Analysis</a></li><li><a class="tocitem" href="../acf/">Autocorrelation Function Analysis</a></li><li><a class="tocitem" href="../covariance/">Correlation Analysis</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Block Bootstrap</a></li><li class="is-active"><a href>Simulation Study</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simulation Study</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DIE-BG/ModelsDataAnalysis" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DIE-BG/ModelsDataAnalysis/blob/main/docs/src/block_bootstrap_exercise.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Block-Bootstrap-Simulation-Exercise"><a class="docs-heading-anchor" href="#Block-Bootstrap-Simulation-Exercise">Block Bootstrap Simulation Exercise</a><a id="Block-Bootstrap-Simulation-Exercise-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Bootstrap-Simulation-Exercise" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>We present an ad-hoc simulation study for the variables used in the macroeconomic models at DIE-BG.  In our quest to assess the macroeconomic models in a robust manner, we aim to generate pseudo-test data using block bootstrap methods. This data can then be used to mimic fresh evaluation data to perform pseudo out-of-sample forecasting.  The purpose of the simulation study presented here is to find suitable block lengths for the stationary and moving block bootstrap methods. </p><p>The outline of the document is as follows.  First, we present a brief introduction to the block bootstrap methods. Then, we describe a basic simulation exercise to perform using the bootstrap methods. Following, we report the results of the basic simulation exercise applied to relevant statistics of the data.  We later compile and summarize those results in a unified metric to obtain insights about an ideal block length parameter for the bootstrap methods. Lastly, we compare our results with those from an optimal block length methodology available in the literature.</p><h2 id="Bootstraping-methods-for-dependent-data"><a class="docs-heading-anchor" href="#Bootstraping-methods-for-dependent-data">Bootstraping methods for dependent data</a><a id="Bootstraping-methods-for-dependent-data-1"></a><a class="docs-heading-anchor-permalink" href="#Bootstraping-methods-for-dependent-data" title="Permalink"></a></h2><p>In the literature, we can find different methods for dependent data.  Some of them are regarded as &quot;first generation methods,&quot; and take as basis fixed-length blocks or variable-length blocks of observations from the original time series.  Blocks are resampled in an independent manner until forming a replication of the time series (usually of the same length as the original sample). In this work, we focus on the moving and the stationary block bootstrap methods.  Following, we present a brief description of these methods. </p><h3 id="Moving-Block-Bootstrap-(MBB)"><a class="docs-heading-anchor" href="#Moving-Block-Bootstrap-(MBB)">Moving Block Bootstrap (MBB)</a><a id="Moving-Block-Bootstrap-(MBB)-1"></a><a class="docs-heading-anchor-permalink" href="#Moving-Block-Bootstrap-(MBB)" title="Permalink"></a></h3><p>We start from a given sample <span>$X_n \equiv \{X_1,...,X_n\}$</span> of size <span>$n$</span>.  Then, we define a block of length <span>$l$</span>, with <span>$l$</span> being a number that satisfies <span>$1\leq l \leq n$</span>.  Once we have defined the block length, we form different blocks of length <span>$l$</span> contained in <span>$X_n$</span> as follows.</p><p class="math-container">\[\begin{aligned}
B_{1} &amp; =\left(X_{1},X_{2},...,X_{l}\right)\\
B_{2} &amp; =\left(X_{2},X_{3},...,X_{l+1}\right)\\
\vdots &amp; =\vdots\\
B_{N} &amp; =\left(X_{n-l+1},...,X_{n}\right)
\end{aligned}\]</p><p>where <span>$N = n-l+1$</span> denotes the number of total blocks of length <span>$l$</span> that will be formed and over which the bootstrap will be applied, allowing overlapping of the blocks in each iteration until the original sample length is reached.  After the <span>$n$</span> bootstrap observations are formed, we proceed to estimate the statistic of interest (the sample mean, the sample variance, the sample autocorrelation function or any other statistic.)</p><h3 id="Stationary-Block-Bootstrap-(SBB)"><a class="docs-heading-anchor" href="#Stationary-Block-Bootstrap-(SBB)">Stationary Block Bootstrap (SBB)</a><a id="Stationary-Block-Bootstrap-(SBB)-1"></a><a class="docs-heading-anchor-permalink" href="#Stationary-Block-Bootstrap-(SBB)" title="Permalink"></a></h3><p>As in the moving block bootstrap, we have a sample of <span>$N$</span> observations of which we assume that they are stationary and time dependent. This method has the property of producing stationary pseudo time series.</p><p>The SBB method shares with the MBB the characteristic of working with blocks of time series that, when joined together, generate a &quot;single block&quot; of length <span>$N$</span> as in the original sample.  The difference between the SBB and the MBB is that the block length in the SBB changes at each iteration, and in the MBB, the length is fixed. The algorithm as follows:</p><p>Let <span>$X_1^*$</span> be an observation drawn at random from the original <span>$N$</span> observations.  <span>$X_1^*$</span> is the first observation of the first block, so <span>$X_1^*$</span> is defined as <span>$X_1^* = X_{I_1}$</span>.  The next one has probability <span>$p$</span> of being randomly drawn from the original <span>$N$</span> observations and probability <span>$1-p$</span> of being <span>$X_2^* = X_{I_1+1}$</span> which be the next one in the original sample.  The process ends when the <span>$X_j^*$</span> is to be drawn at random from the original <span>$N$</span> observations, this being the first observation of the next block.  The iteration ends when we have a number of blocks that being joined together formed a &quot;single block&quot; of length <span>$N$</span>. So, the average length of the blocks is <span>$1/p$</span>.</p><h2 id="Basic-simulation-exercise"><a class="docs-heading-anchor" href="#Basic-simulation-exercise">Basic simulation exercise</a><a id="Basic-simulation-exercise-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-simulation-exercise" title="Permalink"></a></h2><p>In our exercise, the objetive is to sample pseudo datasets using bootstrapping methods on the time series used for building macroeconomic models.  We would like these pseudo time series to adequately replicate some statistical properties of the original series. For example, because we use structural autoregressive models, we would like the pseudo datasets to have time series that exhibit the same mean and variance as the original sample. </p><p>The time series considered are year-on-year rates of change, in quarterly frequency, of the following variables:</p><ol><li>Real GDP of the US (D4L_GDP_RW)</li><li>PCE core inflation (D4L_CPI_RW)</li><li>Effective Federal Funds Rate (RS_RW)</li><li>Domestic real GDP (D4L_GDP)</li><li>Total domestic inflation (D4L_CPI)</li><li>Domestic core inflation (D4L_CPIXFE)</li><li>Exchange rate (GTQ/USD) (D4L_S)</li><li>Monetary base (D4L_MB)</li><li>Monetary policy rate (RS)</li></ol><p>In order to generate robust results in this exercise, we generated <span>$B=10000$</span> bootstrap replications of the dataset. The time series are resampled using a range of possible block lengths.  To check the correct replication of the statistical properties, we computed important statistics for our purposes. These are:</p><ol><li>The sample mean of each of the time series.</li><li>The variance of each of the time series.</li><li>The autocorrelation fuction up to 12 lags (or 3 years in quarterly frequency).</li><li>The correlation matrix between covariates.</li></ol><p>For each bootstrap replication (pseudo time series for a given block length), we compute the above statistics and compare them to the statistics obtained from the actual sample.  The idea is to compare the error that a given boostrap method (and its corresponding parametrization) gives in replicating the statistical properties of each time series. </p><p>We use a Mean Squared Error (MSE) loss function to measure the deviations of the bootstrap methods in producing the observed statistics.  The formula for the MSE of the statistic <span>$\hat{\theta}_{i}^{m}\right$</span> of variable <span>$i$</span> is given as follows: </p><p class="math-container">\[\text{MSE}\left(\hat{\theta}_{i}^{m}\right) =\frac{1}{B}\sum_{b=1}^{B}\left( \hat{\theta}_{i}^{m,(b)} - \theta_{i} \right)^2\]</p><p>Where <span>$\theta_{i}$</span> is the sample statistic in the actual sample. (This is the population parameter in the bootstrap universe.) The MSE is a scale-dependent measure, and thus, their units depend on the statistic we would compute the MSE for.  As we want to generate a measure that combines the overall error of different statistics, we propose using a normalized MSE, which transforms the MSE by the standard deviation of the estimator in all replications.  This modification allows us aggregating the error for statistics of different scales.  So, we calculate a normalized MSE to measure the error between the sample statistic and the original sample statistic, in relation to the variance of the sample statistic, for a given bootsrap method. The normalized MSE is defined as follows:</p><p class="math-container">\[\text{nMSE}\left(\hat{\theta}_{i}^{m}\right)=\frac{1}{B}\sum_{b=1}^{B}\left[\frac{\hat{\theta}_{i}^{m,(b)}-\theta_{i}}{\text{sd}\left(\hat{\theta}_{i}^{m}\right)}\right]^{2}\]</p><p>where <span>$i$</span> is the number of bootstrap replication, <span>$B$</span> is the total number of replications (i.e., 10,000), <span>$\hat{\theta}_{i}^{m}$</span> is the statistic for covariate <span>$i$</span> under block bootstrap method <span>$m$</span> with length <span>$l$</span>. The superindex <span>$(b)$</span> denotes the <span>$b$</span>-th bootstrap replication. <span>$\theta_{i}$</span> is the statistic for covariate <span>$i$</span> observed in the full sample. <span>$\hat\sigma_{i}^{m}$</span> is the standard deviation of the distribution of resampled statistics for covariate <span>$i$</span> under block bootstrap method <span>$m$</span>. </p><p>The normalized MSE takes values around one for any statistic <span>$\theta_i$</span>, so it is very convenient to combine them to obtain a single metric that captures the error for each of the covariates and desired statistics.  Finally, we will compare the overall performance between bootstrap methods by averaging the evaluation metric between covariates, as follows: </p><p class="math-container">\[\text{nMSE}\left(\hat\theta^m\right) = \frac{1}{K} \sum_{k=1}^{K} \text{nMSE}\left(\hat\theta_{k}^{m}\right)\]</p><h2 id="Results-for-the-sample-mean"><a class="docs-heading-anchor" href="#Results-for-the-sample-mean">Results for the sample mean</a><a id="Results-for-the-sample-mean-1"></a><a class="docs-heading-anchor-permalink" href="#Results-for-the-sample-mean" title="Permalink"></a></h2><p>The exercise compares the performance of two methods: the moving (MBB) and the stationary block bootstrap (SBB) in replicating the sample mean for all possible block lengths <span>$l$</span>.  Given our sample size (91 observations) <span>$l$</span> should be a number that satisfies <span>$1\leq l \leq 91$</span>.  For each <span>$l$</span> we generate <span>$B=10,000$</span> pseudo time series with the moving and stationary methods, respectively, and compute the sample mean for each of them. Then, we compare their sample distribution to the historical sample mean. </p><p>The first plot shows the average of the original MSE of all series and the second one the modified MSE. We note that in both cases the best method is the stationary.  However, for the normalized MSE and for all possible block lengths, the mean estimator obtained by the SBB is consistently closer to one, which means that the estimator has low bias for every block length <span>$l$</span> considered.  Notably, the mean estimator of the MBB starts close to one for small block lengths but it consistently deviates from one as the block length gets larger.</p><p><img src="../images/simulation_study/mean/all_MSE.png" alt/> <img src="../images/simulation_study/mean/all_normalized_MSE.png" alt/></p><p>As stated before, we rely on the normalized MSE metric for our analysis, since it allows us to average the error among covariates and aggregate across various statistics of interest.</p><h2 id="Results-for-the-sample-variance"><a class="docs-heading-anchor" href="#Results-for-the-sample-variance">Results for the sample variance</a><a id="Results-for-the-sample-variance-1"></a><a class="docs-heading-anchor-permalink" href="#Results-for-the-sample-variance" title="Permalink"></a></h2><p>For the sample variance of each of the covariates, we follow a similar procedure for comparing between block bootstrap methods as the one used for the sample mean. </p><p><img src="../images/simulation_study/variance/all_MSE.png" alt/> <img src="../images/simulation_study/variance/all_normalized_MSE.png" alt/></p><p>Let us note how the MSE behavior of the sample variance estimator with the MMB method is more volatile than that with the SBB method. This is true for the unnormalized MSE as well as for the normalized MSE. In both cases we prefer the SBB method as the most apropiate method to replicate the sample variance for most block lengths. However, the analysis is still incomplete, as we need to takie into account the sample autocorrelation of each of the covariates and the correlation matrix to determine the best method to replicate the statistics of interest.</p><h2 id="Results-of-the-sample-autocorrelation-function"><a class="docs-heading-anchor" href="#Results-of-the-sample-autocorrelation-function">Results of the sample autocorrelation function</a><a id="Results-of-the-sample-autocorrelation-function-1"></a><a class="docs-heading-anchor-permalink" href="#Results-of-the-sample-autocorrelation-function" title="Permalink"></a></h2><p>For the autocorrelation fuction analysis we have an additional dimension (i.e. the lags of the autocorrelation function entries) to determine the error with respect to the sample autocorrelation function.  In our excercise we consider only 12 lags to generate the sample autocorrelation function. In particular we have an array of dimension <span>$13 \times 10 \times 40 \times 10000$</span>:</p><ul><li>12 lags (plus lag 0).</li><li>10 variables</li><li>40 possible block lengths</li><li>10,000 pseudo time series (block bootstrap series)</li></ul><p>We measure the MSE for all possible block lengths in the same way that in the mean an variance analyses, but the difference is that we have an additional dimension.  To measure the overall MSE, we compute a weighted average over all lags. All weights decay exponentially.</p><p><img src="../images/simulation_study/autocorr/agg_acf_mse_method=stationary_moving.png" alt/> <img src="../images/simulation_study/autocorr/agg_acf_norm_mse_method=stationary_moving.png" alt/></p><p>For both the MBB and the SBB (and for their normalized version of the MSE), the error decays significantly in the first 10 possible block lengths. This property is very important because it tells us about a continuously decaying error for the SBB and a minimum error in the MBB method as we can see in the graphs. To complete the analysis, we will show the results of the last statistic of interest, namely the covariance matrix.</p><h2 id="Results-of-the-sample-correlation-matrix"><a class="docs-heading-anchor" href="#Results-of-the-sample-correlation-matrix">Results of the sample correlation matrix</a><a id="Results-of-the-sample-correlation-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Results-of-the-sample-correlation-matrix" title="Permalink"></a></h2><p>In the same way as the autocorrelation function, the correlation matrix between covariates adds an additional dimension to the analysis to determine the error with respect to the sample correlation matrix. For this analysis, we measured the MSE between the bootstrap samples and the historical estimates using only the lower triangular elements of the correlation matrix.</p><p>The normalized MSE shows the same behavior for the MBB and the SBB methods, with slightly more volatility for the SBB method. Like in others statistics, the SBB method exhibits the best results with consistently smaller MSE than the MBB method.</p><p><img src="../images/simulation_study/cov/cor_mse_method=stationary_moving.png" alt/> <img src="../images/simulation_study/cov/norm_cor_mse_method=stationary_moving.png" alt/></p><p>Consistent with others statistics, the SBB method is the best to replicate the sample covariance matrix characteristics for the different block lengths.</p><h2 id="Unified-metric-for-comparing-block-bootstrap-metrics"><a class="docs-heading-anchor" href="#Unified-metric-for-comparing-block-bootstrap-metrics">Unified metric for comparing block bootstrap metrics</a><a id="Unified-metric-for-comparing-block-bootstrap-metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Unified-metric-for-comparing-block-bootstrap-metrics" title="Permalink"></a></h2><p>As we have four different main statistics that we are concerned the bootstrap samples replicate from the dataset, we propose comparing block bootstrap methods (and possibly other resampling methodologies) by an aggregation of the normalized MSEs for the mean, the variance, and the entries of the autocorrelation function and the correlation matrix between covariates.</p><p>Hereafter, let <span>$i$</span> index a variable and <span>$m$</span> a block bootstrap method. Let <span>$\hat\mu_{i}^{m}$</span> the sample mean estimator. We form the mean component of the unified metric by averaging over covariates:</p><p class="math-container">\[\text{nMSE}\left(\hat{\mu}^{m}\right)=\frac{1}{K}\sum_{k=1}^{K}\text{nMSE}\left(\hat{\mu}_{k}^{m}\right)\]</p><p>Similarly, for the sample variance estimator, <span>$\hat{\sigma^2}_{i}^{m}$</span>, we form the variance component of the unified metric by averaging over covariates: </p><p class="math-container">\[\text{nMSE}\left(\hat{\sigma^{2}}^{m}\right)=\frac{1}{K}\sum_{k=1}^{K}\text{nMSE}\left(\hat{\sigma^{2}}_{k}^{m}\right)\]</p><p>Now, for the autocorrelation function we are evaluating its closeness to the one computed on the whole sample using up to 12 lags.  Let <span>$\hat\gamma_{i,l}^{m}$</span> the <span>$l$</span>-th entry of the sample autocorrelation function, where <span>$l=1,\ldots,12$</span>. (Note <span>$\hat\gamma_{i,0}^{m}=1$</span> always.)   We again combine the MSE for each of the entries of the autocorrelation function using a decaying exponential weighted average as follows: </p><p class="math-container">\[\text{nMSE}\left(\hat{\gamma}_{i}^{m}\right)=\frac{1}{\bar{\alpha}}\sum_{l=1}^{12}\alpha^{i-1}\text{nMSE}\left(\hat{\gamma}_{i,l}^{m}\right)\]</p><p>where, of course, <span>$\bar{\alpha}=\sum_{l=1}^{12}\alpha^{i-1}$</span>. We use <span>$\alpha=0.9$</span>.  Then, the autocorrelation component of the unified metric is computed by averaging over covariates: </p><p class="math-container">\[\text{nMSE}\left(\hat{\gamma}^{m}\right)=\frac{1}{K}\sum_{k=1}^{K}\text{nMSE}\left(\hat{\gamma}_{k}^{m}\right)\]</p><p>Finally, for the correlation between covariates, we follow a similar approach as for the autocorrelation. We average over the normalized MSEs of the sample correlation statistics below the main diagonal of the correlation matrix. </p><p>Let <span>$\hat\rho_{i,j}^{m}$</span> be the samle correlation between covariates <span>$i$</span> and <span>$j$</span> under block bootstrap method <span>$m$</span>. We compute the correlation component of the unified metric by averaging over entries of the lower triangular part of the correlation matrix: </p><p class="math-container">\[\text{nMSE}\left(\hat{\rho}^{m}\right)=\frac{2}{K\left(K-1\right)}\sum_{i=1, j&lt;i}^{K}\text{nMSE}\left(\hat{\rho}_{i,j}^{m}\right)\]</p><p>In sum, the unified metric for bootstrap method <span>$m$</span>, <span>$\text{unMSE}\left(m\right)$</span>, is defined as the sum of four components: </p><p class="math-container">\[\text{unMSE}\left(m\right)=\text{nMSE}\left(\hat{\mu}^{m}\right)+\text{nMSE}\left(\hat{\sigma^{2}}^{m}\right)+\text{nMSE}\left(\hat{\gamma}^{m}\right)+\text{nMSE}\left(\hat{\rho}^{m}\right)\]</p><p>In the following figure, we plot the four components of the unified metric as a function of the block length: </p><p><img src="../images/simulation_study/unified/unified_metrics_components_B=10000_L_autocor=12_L_block=40_method=stationary_moving.png" alt="center"/></p><p>We can see that the autocorrelation dominates the normalized error decomposition because the bias is too high for small block lengths.  In the following figure, we show the behavior of the other three components: </p><p><img src="../images/simulation_study/unified/unified_metrics_components_nacf_B=10000_L_autocor=12_L_block=90_method=stationary_moving.png" alt="center"/></p><p>Then, we compute the sum of the four components to get the unified metric. This is shown in the figure below.  As we can see, the total error decays quickly with the block length for both block methods. This rapid decrease suggests that the block length for resampling the whole dataset (with 91 observations) is not necessarily too big to approximate well the four components we care about with the unified metric.   The MBB exhibits a minimum at <span>$l=19$</span>.  Althought the SBB does not exhibit a minimum value, we find that 95% of the total decrease in the error occurs at a block length <span>$l=10$</span>. This result is, of course, contingent on the maximum block length explored for the resampling, which is <span>$40$</span> for the figure below. However, we re-run the experiment with a maximum block length of <span>$90$</span> (almost the number of observations in the dataset) and find that the 95% decrease in the total error occurs at the block length <span>$l=11$</span>. </p><p><img src="../images/simulation_study/unified/unified_metrics_B=10000_L_autocor=12_L_block=40_method=stationary_moving.png" alt="center"/></p><h2 id="Optimal-block-size-from-the-literature"><a class="docs-heading-anchor" href="#Optimal-block-size-from-the-literature">Optimal block size from the literature</a><a id="Optimal-block-size-from-the-literature-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-block-size-from-the-literature" title="Permalink"></a></h2><p>We compare our insights about the block length with the methodology of  Patton, Politis y White (2009)<sup class="footnote-reference"><a id="citeref-PPW2009" href="#footnote-PPW2009">[PPW2009]</a></sup> (hereafter, PPW). They derive a procedure for obtaining the optimal block length for a time series using spectral methods.  This procedure is available in the Julia library <code>DependentBootstrap.jl</code>.  We apply this procedure to the same individual time series from our dataset. </p><p>The optimal block size estimator in the paper uses a criterion based on minimizing the asymptotic mean squared error of the stationary bootstrap variance estimator.  In the end, their approach relies on estimating the autocovariance structure of the data and selecting a block length that balances capturing dependence and maintaining bootstrap efficiency.</p><h3 id="Politis-and-White&#39;s-(2004)-Proposal-for-the-Optimal-Block-Size"><a class="docs-heading-anchor" href="#Politis-and-White&#39;s-(2004)-Proposal-for-the-Optimal-Block-Size">Politis and White&#39;s (2004) Proposal for the Optimal Block Size</a><a id="Politis-and-White&#39;s-(2004)-Proposal-for-the-Optimal-Block-Size-1"></a><a class="docs-heading-anchor-permalink" href="#Politis-and-White&#39;s-(2004)-Proposal-for-the-Optimal-Block-Size" title="Permalink"></a></h3><p>We present an introduction of Politis and White&#39;s (2004)<sup class="footnote-reference"><a id="citeref-PW2004" href="#footnote-PW2004">[PW2004]</a></sup> methodology for estimating the optimal (expected) block size of the stationary bootstrap. From a theorem in Lahiri (1999),<sup class="footnote-reference"><a id="citeref-Lahiri1999" href="#footnote-Lahiri1999">[Lahiri1999]</a></sup> Politis and White (2004) derive: </p><p class="math-container">\[\text{MSE}\left(\hat{\sigma}_{b,SB}^{2}\right)=\frac{G^{2}}{b^{2}}+D_{SB}\frac{b}{N}+o\left(b^{-2}\right)+o\left(b/N\right),\]</p><p>so, the large-sample <span>$\text{MSE}\left(\hat{\sigma}_{b,SB}^{2}\right)$</span> is minimized when choosing </p><p class="math-container">\[b_{opt,SB}=\left(\frac{2G^{2}}{D_{SB}}\right)^{1/3}N^{1/3}.\]</p><p>In the above equations, the sample size is <span>$N$</span>, and the quantities <span>$D_{SB}$</span> and <span>$G$</span> depend on the autocovariance function, <span>$R\left(k\right)$</span>, and the power spectral density function, <span>$g(w)$</span>, of the time series: </p><p class="math-container">\[\begin{aligned}
D_{SB} &amp; =2g^{2}\left(0\right) \\ 
G &amp;=\sum_{k=-\infty}^{\infty}|k|R\left(k\right). \\
\end{aligned}\]</p><p>Next, Politis and White (2004)<sup class="footnote-reference"><a id="citeref-PW2004" href="#footnote-PW2004">[PW2004]</a></sup> use the &quot;flat-top&quot; lag-window of Politis and Romano (1995)<sup class="footnote-reference"><a id="citeref-PR1995" href="#footnote-PR1995">[PR1995]</a></sup> to estimate the infinite sums involved in the calculation of <span>$G$</span> and <span>$g(w)$</span>. So, they provide a final estimator for the optimal block size: </p><p class="math-container">\[\begin{aligned}
\hat{g}\left(w\right) &amp; =\sum_{k=-M}^{M}\lambda\left(k/M\right)\hat{R}\left(k\right)\cos\left(wk\right), \\
\hat{G}	&amp; =\sum_{k=-M}^{M}\lambda\left(k/M\right)|k|\hat{R}\left(k\right), \\
\hat{D}_{SB} &amp; =2\hat{g}^{2}\left(0\right) \\
\end{aligned}\]</p><p>In the above, <span>$\hat{R}$</span> is the sample autocovariance function, <span>$\lambda\left(\cdot\right)$</span> is the flat-top trapezoidal window function. The expressions depend also on the parameter <span>$M$</span>, which Politis and White (2004) recommend choosing by inspection of the correlogram.<sup class="footnote-reference"><a id="citeref-M" href="#footnote-M">[M]</a></sup></p><p>The expressions above for <span>$D_{SB}$</span> were corrected by Patton, Politis and White (2009), since Nordman (2008)<sup class="footnote-reference"><a id="citeref-Nordman2008" href="#footnote-Nordman2008">[Nordman2008]</a></sup> discovered an error in Lahiri&#39;s (1999) calculation of the variance associated with the stationary bootstrap. The final expression above for <span>$D_{SB}$</span> is much simpler than the original (erroneous) expression from Politis and White (2004). </p><h3 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h3><p>The following figure shows the results of applying PPW to each of the time series in our dataset. We can see that most series require a block length of less than 10. However, time series like core inflation (D4L_CPIXFE) and the year-on-year change of the exchange rate (D4L_S) require a higher block length, as they are more persistent, and thus, their correlogram functions decay slower. The figure also shows the average and the median block length.  The Julia library computes the median by default to combine the different block lengths for a dataset. Unfortunately, we could not found any formal criteria to choose the block length for a multivariate dataset.  </p><p><img src="../images/simulation_study/optblock/ppw2009_optimal_block_length_data=d4l.png" alt="center"/></p><h2 id="Concluding-remarks"><a class="docs-heading-anchor" href="#Concluding-remarks">Concluding remarks</a><a id="Concluding-remarks-1"></a><a class="docs-heading-anchor-permalink" href="#Concluding-remarks" title="Permalink"></a></h2><p>In this simulation study we presented a methodology to compare the performance of the moving and stationary block bootstrap methods in replicating the statistical properties of a dataset. We used a unified metric to compare the performance of the two methods in replicating the sample mean, variance, autocorrelation function, and correlation matrix between covariates. We found that the stationary block bootstrap method outperforms the moving block bootstrap method in all statistics of interest. We also compared our results with the optimal block length methodology proposed by Patton, Politis, and White (2009) and found that the optimal block length is consistent with the results obtained from our simulation study. Moreover, the methodology presented here can be used to determine the optimal block length for the block bootstrap method in a dataset of interest. We leave for future work the extension of this methodology to other resampling methods, such as frequency domain bootstrap methods. </p><h2 id="Appendix:-Normalized-MSE-interpretation"><a class="docs-heading-anchor" href="#Appendix:-Normalized-MSE-interpretation">Appendix: Normalized MSE interpretation</a><a id="Appendix:-Normalized-MSE-interpretation-1"></a><a class="docs-heading-anchor-permalink" href="#Appendix:-Normalized-MSE-interpretation" title="Permalink"></a></h2><p>In the bootstrap world, let <span>$\theta$</span> be an observed statistic and <span>$\hat{\theta}$</span> be an estimator of such quantity. We can compute the standard deviation of the bootstrap sample distribution of <span>$\hat{\theta}$</span>, <span>$\text{sd}\left(\hat\theta\right)$</span>, to normalize the mean squared error.  Expanding this normalized MSE formula, we obtain: </p><p class="math-container">\[\begin{aligned}
\text{nMSE}\left(\hat{\theta}\right) &amp; =\frac{1}{B}\sum_{b=1}^{B}\left[\frac{\hat{\theta}^{(b)}-\theta}{\text{sd}\left(\hat{\theta}\right)}\right]^{2}\\
 &amp; =\frac{1}{\text{Var}\left(\hat{\theta}\right)}\cdot\frac{1}{B}\sum_{b=1}^{B}\left(\hat{\theta}^{(b)}-\theta\right)^{2}\\
 &amp; =\frac{1}{\text{Var}\left(\hat{\theta}\right)}\cdot\text{MSE}\left(\hat{\theta}\right)\\
 &amp; =\frac{1}{\text{Var}\left(\hat{\theta}\right)}\cdot\left[\text{Var}\left(\hat{\theta}\right)+\text{Bias}\left(\hat{\theta}\right)^{2}\right]\\
 &amp; =1+\frac{\text{Bias}\left(\hat{\theta}\right)^{2}}{\text{Var}\left(\hat{\theta}\right)}
\end{aligned}\]</p><p>Thus, this measure is one (unitless) for unbiased estimators. In contrast, if the bias of the estimator is small, the <span>$\text{nMSE}$</span> will be close to one. </p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-PPW2009"><a class="tag is-link" href="#citeref-PPW2009">PPW2009</a>Patton, A., Politis, D. N., &amp; White, H. (2009). Correction to “Automatic block-length selection for the dependent bootstrap” by D. Politis and H. White. Econometric Reviews, 28(4), 372-375.</li><li class="footnote" id="footnote-M"><a class="tag is-link" href="#citeref-M">M</a>In particular, Politis and Romano (1995) suggest looking for the smallest integer, say <span>$\hat{m}$</span>, after which the correlogram appears negligible, i.e., <span>$\hat{R}(k) \approx 0$</span> for <span>$k&gt;\hat{m}$</span>. After identifying this value on the correlogram, the recomendation is to take <span>$M=2\hat{m}$</span>. </li><li class="footnote" id="footnote-PW2004"><a class="tag is-link" href="#citeref-PW2004">PW2004</a>Politis, D. N., White, H. (2004). Automatic block-length selection for the dependent bootstrap. Econometric Reviews 23(1):53–70</li><li class="footnote" id="footnote-PR1995"><a class="tag is-link" href="#citeref-PR1995">PR1995</a>Politis, D. N., Romano, J. P. (1995). Bias-corrected nonparametric spectral estimation. J. Time Series Anal. 16:67–103.</li><li class="footnote" id="footnote-Lahiri1999"><a class="tag is-link" href="#citeref-Lahiri1999">Lahiri1999</a>Lahiri, S. N. (1999). Theoretical comparisons of block bootstrap methods. Annals of Statistics 27:386–404</li><li class="footnote" id="footnote-Nordman2008"><a class="tag is-link" href="#citeref-Nordman2008">Nordman2008</a>Nordman, D. J. (2008). A note on the stationary bootstrap&#39;s variance. Annals of Statistics</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../periodogram/">« Frequency Analysis</a><a class="docs-footer-nextpage" href="../mean/">Mean Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 21 March 2025 18:00">Friday 21 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
